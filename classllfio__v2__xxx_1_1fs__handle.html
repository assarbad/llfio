<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLFIO: llfio_v2_xxx::fs_handle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLFIO
   &#160;<span id="projectnumber">v2.00 late beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classllfio__v2__xxx_1_1fs__handle.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classllfio__v2__xxx_1_1fs__handle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">llfio_v2_xxx::fs_handle Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A handle to something with a device and inode number.  
 <a href="classllfio__v2__xxx_1_1fs__handle.html#details">More...</a></p>

<p><code>#include &quot;fs_handle.hpp&quot;</code></p>
<div class="dynheader">
Inheritance diagram for llfio_v2_xxx::fs_handle:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classllfio__v2__xxx_1_1fs__handle.png" usemap="#llfio_5Fv2_5Fxxx::fs_5Fhandle_map" alt=""/>
  <map id="llfio_5Fv2_5Fxxx::fs_5Fhandle_map" name="llfio_5Fv2_5Fxxx::fs_5Fhandle_map">
<area href="classllfio__v2__xxx_1_1directory__handle.html" title="A handle to a directory which can be enumerated." alt="llfio_v2_xxx::directory_handle" shape="rect" coords="0,56,222,80"/>
<area href="classllfio__v2__xxx_1_1file__handle.html" title="A handle to a regular file or device." alt="llfio_v2_xxx::file_handle" shape="rect" coords="232,56,454,80"/>
<area href="classllfio__v2__xxx_1_1pipe__handle.html" title="A handle to a named or anonymous pipe." alt="llfio_v2_xxx::pipe_handle" shape="rect" coords="464,56,686,80"/>
<area href="classllfio__v2__xxx_1_1symlink__handle.html" title="A handle to an inode which redirects to a different path." alt="llfio_v2_xxx::symlink_handle" shape="rect" coords="696,56,918,80"/>
<area href="classllfio__v2__xxx_1_1fast__random__file__handle.html" title="A handle to synthesised, non-cryptographic, pseudo-random data." alt="llfio_v2_xxx::fast_random_file_handle" shape="rect" coords="116,112,338,136"/>
<area href="classllfio__v2__xxx_1_1mapped__file__handle.html" title="A memory mapped regular file or device." alt="llfio_v2_xxx::mapped_file_handle" shape="rect" coords="348,112,570,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac43e0058de471b7b8c4a9f08e621038f"><td class="memItemLeft" align="right" valign="top"><a id="ac43e0058de471b7b8c4a9f08e621038f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>dev_t</b> = uint64_t</td></tr>
<tr class="separator:ac43e0058de471b7b8c4a9f08e621038f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6716da1bdd65c32c91eb3e4f34ccde98"><td class="memItemLeft" align="right" valign="top"><a id="a6716da1bdd65c32c91eb3e4f34ccde98"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ino_t</b> = uint64_t</td></tr>
<tr class="separator:a6716da1bdd65c32c91eb3e4f34ccde98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd8c8171f4e561620864295e8d5879b"><td class="memItemLeft" align="right" valign="top"><a id="abcd8c8171f4e561620864295e8d5879b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#abcd8c8171f4e561620864295e8d5879b">path_view_type</a> = <a class="el" href="classllfio__v2__xxx_1_1path__view.html">path_view</a></td></tr>
<tr class="memdesc:abcd8c8171f4e561620864295e8d5879b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The path view type used by this handle. <br /></td></tr>
<tr class="separator:abcd8c8171f4e561620864295e8d5879b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a65884346740af7fb4648c79d44a750"><td class="memItemLeft" align="right" valign="top"><a id="a1a65884346740af7fb4648c79d44a750"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a1a65884346740af7fb4648c79d44a750">unique_id_type</a> = QUICKCPPLIB_NAMESPACE::integers128::uint128</td></tr>
<tr class="memdesc:a1a65884346740af7fb4648c79d44a750"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique identifier type used by this handle. <br /></td></tr>
<tr class="separator:a1a65884346740af7fb4648c79d44a750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82a83c5e44659e01a2218f0af41bde7"><td class="memItemLeft" align="right" valign="top"><a id="ab82a83c5e44659e01a2218f0af41bde7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#ab82a83c5e44659e01a2218f0af41bde7">unique_id_type_hasher</a> = QUICKCPPLIB_NAMESPACE::integers128::uint128_hasher</td></tr>
<tr class="memdesc:ab82a83c5e44659e01a2218f0af41bde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hasher for the unique identifier type used by this handle. <br /></td></tr>
<tr class="separator:ab82a83c5e44659e01a2218f0af41bde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afbebcaabf0282923ff76f6a83d3b4073"><td class="memItemLeft" align="right" valign="top"><a id="afbebcaabf0282923ff76f6a83d3b4073"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#afbebcaabf0282923ff76f6a83d3b4073">fs_handle</a> (const <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;)=delete</td></tr>
<tr class="memdesc:afbebcaabf0282923ff76f6a83d3b4073"><td class="mdescLeft">&#160;</td><td class="mdescRight">No copy construction (use <code>clone()</code>) <br /></td></tr>
<tr class="separator:afbebcaabf0282923ff76f6a83d3b4073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d3ff8122c08cdbcf876f2e4ee6564b"><td class="memItemLeft" align="right" valign="top"><a id="a09d3ff8122c08cdbcf876f2e4ee6564b"></a>
<a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a09d3ff8122c08cdbcf876f2e4ee6564b">operator=</a> (const <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;o)=delete</td></tr>
<tr class="memdesc:a09d3ff8122c08cdbcf876f2e4ee6564b"><td class="mdescLeft">&#160;</td><td class="mdescRight">No copy assignment. <br /></td></tr>
<tr class="separator:a09d3ff8122c08cdbcf876f2e4ee6564b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24ed4cdb96690d7da95cd17b0f3d090"><td class="memItemLeft" align="right" valign="top"><a id="ac24ed4cdb96690d7da95cd17b0f3d090"></a>
dev_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#ac24ed4cdb96690d7da95cd17b0f3d090">st_dev</a> () const noexcept</td></tr>
<tr class="memdesc:ac24ed4cdb96690d7da95cd17b0f3d090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unless <code>flag::disable_safety_unlinks</code> is set, the device id of the file when opened. <br /></td></tr>
<tr class="separator:ac24ed4cdb96690d7da95cd17b0f3d090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6465d30ee438b860ccc59c0e0fc4dc"><td class="memItemLeft" align="right" valign="top"><a id="aad6465d30ee438b860ccc59c0e0fc4dc"></a>
ino_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#aad6465d30ee438b860ccc59c0e0fc4dc">st_ino</a> () const noexcept</td></tr>
<tr class="memdesc:aad6465d30ee438b860ccc59c0e0fc4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unless <code>flag::disable_safety_unlinks</code> is set, the inode of the file when opened. When combined with st_dev(), forms a unique identifer on this system. <br /></td></tr>
<tr class="separator:aad6465d30ee438b860ccc59c0e0fc4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9793fe40564fda2437783488bd51b9f1"><td class="memItemLeft" align="right" valign="top"><a id="a9793fe40564fda2437783488bd51b9f1"></a>
<a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a1a65884346740af7fb4648c79d44a750">unique_id_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a9793fe40564fda2437783488bd51b9f1">unique_id</a> () const noexcept</td></tr>
<tr class="memdesc:a9793fe40564fda2437783488bd51b9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique identifier for this handle across the entire system. Can be used in hash tables etc. <br /></td></tr>
<tr class="separator:a9793fe40564fda2437783488bd51b9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865caad2f7f4bdf12fb74aabfe3c5ff5"><td class="memItemLeft" align="right" valign="top">virtual result&lt; <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a865caad2f7f4bdf12fb74aabfe3c5ff5">parent_path_handle</a> (<a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=std::chrono::seconds(30)) const noexcept</td></tr>
<tr class="separator:a865caad2f7f4bdf12fb74aabfe3c5ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eeaf9d77a1279b4f0d3062de509f77f"><td class="memTemplParams" colspan="2"><a id="a1eeaf9d77a1279b4f0d3062de509f77f"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a1eeaf9d77a1279b4f0d3062de509f77f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_parent_path_handle</b> (Args &amp;&amp;... args) noexcept</td></tr>
<tr class="separator:a1eeaf9d77a1279b4f0d3062de509f77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ea4bd2d5a66fbde4cdbfe463166a4f"><td class="memTemplParams" colspan="2"><a id="a41ea4bd2d5a66fbde4cdbfe463166a4f"></a>
template&lt;class... Args, class Rep , class Period &gt; </td></tr>
<tr class="memitem:a41ea4bd2d5a66fbde4cdbfe463166a4f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_parent_path_handle_for</b> (Args &amp;&amp;... args, const std::chrono::duration&lt; Rep, Period &gt; &amp;duration) noexcept</td></tr>
<tr class="separator:a41ea4bd2d5a66fbde4cdbfe463166a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb1fe8c7901382307d84848fdc0afcb"><td class="memTemplParams" colspan="2"><a id="acbb1fe8c7901382307d84848fdc0afcb"></a>
template&lt;class... Args, class Clock , class Duration &gt; </td></tr>
<tr class="memitem:acbb1fe8c7901382307d84848fdc0afcb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_parent_path_handle_until</b> (Args &amp;&amp;... args, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout) noexcept</td></tr>
<tr class="separator:acbb1fe8c7901382307d84848fdc0afcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8700edc9ecd4dd35d5aad7c65dd0eca2"><td class="memItemLeft" align="right" valign="top">virtual result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a8700edc9ecd4dd35d5aad7c65dd0eca2">relink</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;base, <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#abcd8c8171f4e561620864295e8d5879b">path_view_type</a> <a class="el" href="namespacellfio__v2__xxx.html#a49f7bb77eb38fbe1280019225b66b78b">path</a>, bool atomic_replace=true, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=std::chrono::seconds(30)) noexcept</td></tr>
<tr class="separator:a8700edc9ecd4dd35d5aad7c65dd0eca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5f9892f6652359f2330bf6d9b89e17"><td class="memTemplParams" colspan="2"><a id="a7f5f9892f6652359f2330bf6d9b89e17"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a7f5f9892f6652359f2330bf6d9b89e17"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_relink</b> (Args &amp;&amp;... args) noexcept</td></tr>
<tr class="separator:a7f5f9892f6652359f2330bf6d9b89e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5565cd5f2fcbb9472b2a00795cc0bcc"><td class="memTemplParams" colspan="2"><a id="af5565cd5f2fcbb9472b2a00795cc0bcc"></a>
template&lt;class... Args, class Rep , class Period &gt; </td></tr>
<tr class="memitem:af5565cd5f2fcbb9472b2a00795cc0bcc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_relink_for</b> (Args &amp;&amp;... args, const std::chrono::duration&lt; Rep, Period &gt; &amp;duration) noexcept</td></tr>
<tr class="separator:af5565cd5f2fcbb9472b2a00795cc0bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc4e2ade67dfb9140007cc31f4b6b20"><td class="memTemplParams" colspan="2"><a id="a1fc4e2ade67dfb9140007cc31f4b6b20"></a>
template&lt;class... Args, class Clock , class Duration &gt; </td></tr>
<tr class="memitem:a1fc4e2ade67dfb9140007cc31f4b6b20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_relink_until</b> (Args &amp;&amp;... args, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout) noexcept</td></tr>
<tr class="separator:a1fc4e2ade67dfb9140007cc31f4b6b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7770c6b7c478d74654f25b8c1a1585c"><td class="memItemLeft" align="right" valign="top">virtual result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#aa7770c6b7c478d74654f25b8c1a1585c">link</a> (const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;base, <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#abcd8c8171f4e561620864295e8d5879b">path_view_type</a> <a class="el" href="namespacellfio__v2__xxx.html#a49f7bb77eb38fbe1280019225b66b78b">path</a>, <a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=std::chrono::seconds(30)) noexcept</td></tr>
<tr class="separator:aa7770c6b7c478d74654f25b8c1a1585c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43b812385c7fc8aae9e59838a1411bb"><td class="memTemplParams" colspan="2"><a id="ad43b812385c7fc8aae9e59838a1411bb"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ad43b812385c7fc8aae9e59838a1411bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_link</b> (Args &amp;&amp;... args) noexcept</td></tr>
<tr class="separator:ad43b812385c7fc8aae9e59838a1411bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d73e0e89bac484ce40427b58dcfe53"><td class="memTemplParams" colspan="2"><a id="a65d73e0e89bac484ce40427b58dcfe53"></a>
template&lt;class... Args, class Rep , class Period &gt; </td></tr>
<tr class="memitem:a65d73e0e89bac484ce40427b58dcfe53"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_link_for</b> (Args &amp;&amp;... args, const std::chrono::duration&lt; Rep, Period &gt; &amp;duration) noexcept</td></tr>
<tr class="separator:a65d73e0e89bac484ce40427b58dcfe53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2703814c7599d2081ca10763bbeba4a"><td class="memTemplParams" colspan="2"><a id="ad2703814c7599d2081ca10763bbeba4a"></a>
template&lt;class... Args, class Clock , class Duration &gt; </td></tr>
<tr class="memitem:ad2703814c7599d2081ca10763bbeba4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_link_until</b> (Args &amp;&amp;... args, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout) noexcept</td></tr>
<tr class="separator:ad2703814c7599d2081ca10763bbeba4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd7923bb65456af4da41ebe7cb84982"><td class="memItemLeft" align="right" valign="top">virtual result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a1dd7923bb65456af4da41ebe7cb84982">unlink</a> (<a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a> d=std::chrono::seconds(30)) noexcept</td></tr>
<tr class="separator:a1dd7923bb65456af4da41ebe7cb84982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f77a249baf4e0c5de2172669a7724d7"><td class="memTemplParams" colspan="2"><a id="a7f77a249baf4e0c5de2172669a7724d7"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a7f77a249baf4e0c5de2172669a7724d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_unlink</b> (Args &amp;&amp;... args) noexcept</td></tr>
<tr class="separator:a7f77a249baf4e0c5de2172669a7724d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209de025a2d3e202a61c50b52d43f2af"><td class="memTemplParams" colspan="2"><a id="a209de025a2d3e202a61c50b52d43f2af"></a>
template&lt;class... Args, class Rep , class Period &gt; </td></tr>
<tr class="memitem:a209de025a2d3e202a61c50b52d43f2af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_unlink_for</b> (Args &amp;&amp;... args, const std::chrono::duration&lt; Rep, Period &gt; &amp;duration) noexcept</td></tr>
<tr class="separator:a209de025a2d3e202a61c50b52d43f2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c4133fef23811abcb01e1faf2b19d3"><td class="memTemplParams" colspan="2"><a id="ae9c4133fef23811abcb01e1faf2b19d3"></a>
template&lt;class... Args, class Clock , class Duration &gt; </td></tr>
<tr class="memitem:ae9c4133fef23811abcb01e1faf2b19d3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_unlink_until</b> (Args &amp;&amp;... args, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout) noexcept</td></tr>
<tr class="separator:ae9c4133fef23811abcb01e1faf2b19d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adc2b24484565bcb0cf654adf2f732f7e"><td class="memItemLeft" align="right" valign="top"><a id="adc2b24484565bcb0cf654adf2f732f7e"></a>
result&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#adc2b24484565bcb0cf654adf2f732f7e">_fetch_inode</a> () const noexcept</td></tr>
<tr class="memdesc:adc2b24484565bcb0cf654adf2f732f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in _devid and _inode from the handle via fstat() <br /></td></tr>
<tr class="separator:adc2b24484565bcb0cf654adf2f732f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8b8b7eb5a31bfc94c5bc7eb189fe45"><td class="memItemLeft" align="right" valign="top"><a id="a5a8b8b7eb5a31bfc94c5bc7eb189fe45"></a>
virtual const <a class="el" href="classllfio__v2__xxx_1_1handle.html">handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_get_handle</b> () const noexcept=0</td></tr>
<tr class="separator:a5a8b8b7eb5a31bfc94c5bc7eb189fe45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2070f6019c86e19de3707bf59ffa97"><td class="memItemLeft" align="right" valign="top"><a id="a1d2070f6019c86e19de3707bf59ffa97"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a1d2070f6019c86e19de3707bf59ffa97">fs_handle</a> ()</td></tr>
<tr class="memdesc:a1d2070f6019c86e19de3707bf59ffa97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a1d2070f6019c86e19de3707bf59ffa97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282f0296cda08ad5ce2f9add2c16a77d"><td class="memItemLeft" align="right" valign="top"><a id="a282f0296cda08ad5ce2f9add2c16a77d"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a282f0296cda08ad5ce2f9add2c16a77d">fs_handle</a> (dev_t devid, ino_t inode)</td></tr>
<tr class="memdesc:a282f0296cda08ad5ce2f9add2c16a77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a handle. <br /></td></tr>
<tr class="separator:a282f0296cda08ad5ce2f9add2c16a77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cc7b561e6ef3a54ccfb2c4743e5c6f"><td class="memItemLeft" align="right" valign="top"><a id="a69cc7b561e6ef3a54ccfb2c4743e5c6f"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a69cc7b561e6ef3a54ccfb2c4743e5c6f">fs_handle</a> (<a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:a69cc7b561e6ef3a54ccfb2c4743e5c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit move construction of fs_handle permitted. <br /></td></tr>
<tr class="separator:a69cc7b561e6ef3a54ccfb2c4743e5c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf55c5a6edb8cde2b8d2fb1f76348ba"><td class="memItemLeft" align="right" valign="top"><a id="aaaf55c5a6edb8cde2b8d2fb1f76348ba"></a>
<a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#aaaf55c5a6edb8cde2b8d2fb1f76348ba">operator=</a> (<a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:aaaf55c5a6edb8cde2b8d2fb1f76348ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment of fs_handle permitted. <br /></td></tr>
<tr class="separator:aaaf55c5a6edb8cde2b8d2fb1f76348ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4d20a64cf182162a49962ed25d2126b3"><td class="memItemLeft" align="right" valign="top"><a id="a4d20a64cf182162a49962ed25d2126b3"></a>
dev_t&#160;</td><td class="memItemRight" valign="bottom"><b>_devid</b> {0}</td></tr>
<tr class="separator:a4d20a64cf182162a49962ed25d2126b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8454764db3cd47e65ec7853b9cb0b3fa"><td class="memItemLeft" align="right" valign="top"><a id="a8454764db3cd47e65ec7853b9cb0b3fa"></a>
ino_t&#160;</td><td class="memItemRight" valign="bottom"><b>_inode</b> {0}</td></tr>
<tr class="separator:a8454764db3cd47e65ec7853b9cb0b3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0fd0de38fa849bfd8a8771a02679b1b4"><td class="memItemLeft" align="right" valign="top">result&lt; filesystem::path &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#a0fd0de38fa849bfd8a8771a02679b1b4">to_win32_path</a> (const <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;h, <a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89a">win32_path_namespace</a>) noexcept</td></tr>
<tr class="memdesc:a0fd0de38fa849bfd8a8771a02679b1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the current path of <code>h</code> into a form suitable for Win32 APIs. Passes through unmodified on POSIX, so you can use this in portable code.  <a href="classllfio__v2__xxx_1_1fs__handle.html#a0fd0de38fa849bfd8a8771a02679b1b4">More...</a><br /></td></tr>
<tr class="separator:a0fd0de38fa849bfd8a8771a02679b1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A handle to something with a device and inode number. </p>
<dl class="section see"><dt>See also</dt><dd><code>algorithm::cached_parent_handle_adapter&lt;T&gt;</code> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa7770c6b7c478d74654f25b8c1a1585c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7770c6b7c478d74654f25b8c1a1585c">&#9670;&nbsp;</a></span>link()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt;void&gt; llfio_v2_xxx::fs_handle::link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#abcd8c8171f4e561620864295e8d5879b">path_view_type</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>std::chrono::seconds(30)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Links the inode referred to by this open handle to the path specified. The current path of this open handle is not changed, unless it has no current path due to being unlinked.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for linking an open handle to a new location (Linux, Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong inode being linked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory first, then checks before linking that the item about to be hard linked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base for any relative path. </td></tr>
    <tr><td class="paramname">path</td><td>The relative or absolute new path to hard link to. </td></tr>
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n Except on platforms with race free syscalls for renaming open handles (Windows), calls</dt><dd><code>current_path()</code> via <code>parent_path_handle()</code> and thus is both expensive and calls malloc many times. </dd></dl>

</div>
</div>
<a id="a865caad2f7f4bdf12fb74aabfe3c5ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865caad2f7f4bdf12fb74aabfe3c5ff5">&#9670;&nbsp;</a></span>parent_path_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt;<a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a>&gt; llfio_v2_xxx::fs_handle::parent_path_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>std::chrono::seconds(30)</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain a handle to the path <b>currently</b> containing this handle's file entry.</p>
<dl class="section warning"><dt>Warning</dt><dd>This call is <b>racy</b> and can result in the wrong path handle being returned. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory, then checks if the file entry within has the same inode as the open file handle. It will retry this matching until success until the deadline given.</dd></dl>
<dl class="section user"><dt>Memory Allocations\n Calls current_path() and thus is both expensive and calls malloc many times.</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code>algorithm::cached_parent_handle_adapter&lt;T&gt;</code> which overrides this with a zero cost implementation, thus making unlinking and relinking very considerably quicker. </dd></dl>

</div>
</div>
<a id="a8700edc9ecd4dd35d5aad7c65dd0eca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8700edc9ecd4dd35d5aad7c65dd0eca2">&#9670;&nbsp;</a></span>relink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt;void&gt; llfio_v2_xxx::fs_handle::relink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1path__handle.html">path_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html#abcd8c8171f4e561620864295e8d5879b">path_view_type</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>atomic_replace</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>std::chrono::seconds(30)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Relinks the current path of this open handle to the new path specified. If <code>atomic_replace</code> is true, the relink <b>atomically</b> and silently replaces any item at the new path specified. This operation is both atomic and matching POSIX behaviour even on Microsoft Windows where no Win32 API can match POSIX semantics.</p>
<p>Note that if <code>atomic_replace</code> is false, the operation <em>may</em> be implemented as creating a hard link to the destination (which fails if the destination exists), opening a new file descriptor to the destination, closing the existing file descriptor, replacing the existing file descriptor with the new one (this is to ensure path tracking continues to work), then unlinking the previous link. Thus <code>native_handle()</code>'s value <em>may</em> change. This is not the case on Microsoft Windows nor Linux, both of which provide syscalls capable of refusing to rename if the destination exists.</p>
<p>If the handle refers to a pipe, on Microsoft Windows the base path handle is ignored as there is a single global named pipe namespace. Unless the path fragment begins with <code>\</code>, the string <code>\??\</code> is prefixed to the name before passing it to the NT kernel API which performs the rename. This is because <code>\\.\</code> in Win32 maps onto <code>\??\</code> in the NT kernel.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for renaming an open handle (Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong file entry being relinked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the source containing directory first, then checks before relinking that the item about to be relinked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Base for any relative path. </td></tr>
    <tr><td class="paramname">path</td><td>The relative or absolute new path to relink to. </td></tr>
    <tr><td class="paramname">atomic_replace</td><td>Atomically replace the destination if a file entry already is present there. Choosing false for this will fail if a file entry is already present at the destination, and may not be an atomic operation on some platforms (i.e. both the old and new names may be linked to the same inode for a very short period of time). Windows and recent Linuxes are always atomic. </td></tr>
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n Except on platforms with race free syscalls for renaming open handles (Windows), calls</dt><dd><code>current_path()</code> via <code>parent_path_handle()</code> and thus is both expensive and calls malloc many times. </dd></dl>

<p>Reimplemented in <a class="el" href="classllfio__v2__xxx_1_1mapped__file__handle.html#a35d3754438d64a63a7fe63c5ade23a62">llfio_v2_xxx::mapped_file_handle</a>, and <a class="el" href="classllfio__v2__xxx_1_1symlink__handle.html#afea9ef2b36cac3f6dfcae7555ca3303c">llfio_v2_xxx::symlink_handle</a>.</p>

</div>
</div>
<a id="a1dd7923bb65456af4da41ebe7cb84982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd7923bb65456af4da41ebe7cb84982">&#9670;&nbsp;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual result&lt;void&gt; llfio_v2_xxx::fs_handle::unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllfio__v2__xxx_1_1deadline.html">deadline</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code>std::chrono::seconds(30)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlinks the current path of this open handle, causing its entry to immediately disappear from the filing system. On Windows before Windows 10 1709 unless <code>flag::win_disable_unlink_emulation</code> is set, this behaviour is simulated by renaming the file to something random and setting its delete-on-last-close flag. Note that Windows may prevent the renaming of a file in use by another process, if so it will NOT be renamed. After the next handle to that file closes, it will become permanently unopenable by anyone else until the last handle is closed, whereupon the entry will be eventually removed by the operating system.</p>
<dl class="section warning"><dt>Warning</dt><dd>Some operating systems provide a race free syscall for unlinking an open handle (Windows). On all other operating systems this call is <b>racy</b> and can result in the wrong file entry being unlinked. Note that unless <code>flag::disable_safety_unlinks</code> is set, this implementation opens a <code>path_handle</code> to the containing directory first, then checks that the item about to be unlinked has the same inode as the open file handle. It will retry this matching until success until the deadline given. This should prevent most unmalicious accidental loss of data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The deadline by which the matching of the containing directory to the open handle's inode must succeed, else <code>errc::timed_out</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Memory Allocations\n Except on platforms with race free syscalls for unlinking open handles (Windows), calls</dt><dd><code>current_path()</code> and thus is both expensive and calls malloc many times. On Windows, also calls <code>current_path()</code> if <code>flag::disable_safety_unlinks</code> is not set. </dd></dl>

<p>Reimplemented in <a class="el" href="classllfio__v2__xxx_1_1symlink__handle.html#a002c9dab669604d58e08aa8f4dbc99c8">llfio_v2_xxx::symlink_handle</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0fd0de38fa849bfd8a8771a02679b1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd0de38fa849bfd8a8771a02679b1b4">&#9670;&nbsp;</a></span>to_win32_path</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt;filesystem::path&gt; to_win32_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellfio__v2__xxx.html#abcb445e5dfcc0eb04ce49ac8af0bc89a">win32_path_namespace</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps the current path of <code>h</code> into a form suitable for Win32 APIs. Passes through unmodified on POSIX, so you can use this in portable code. </p>
<dl class="section return"><dt>Returns</dt><dd>The mapped current path of <code>h</code>, which may have been validated to refer to the exact same inode via <code>.unique_id()</code> (see below). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The handle whose <code>.current_path()</code> is to be mapped into a form suitable for Win32 APIs. </td></tr>
    <tr><td class="paramname">mapping</td><td>Which Win32 path namespace to map onto.</td></tr>
  </table>
  </dd>
</dl>
<p>This implementation may need to validate that the mapping of the current path of <code>h</code> onto the desired Win32 path namespace does indeed refer to the same file:</p>
<ul>
<li><code>win32_path_namespace::device</code> transforms <code>\!!\Device\...</code> =&gt; <code>\\.\...</code> and ensures that the mapped file's unique id matches the original, otherwise returning failure.</li>
<li><code>win32_path_namespace::dos</code> enumerates all the DOS devices on the system and what those map onto within the NT kernel namespace. This mapping is for obvious reasons quite slow.</li>
<li><code>win32_path_namespace::guid_volume</code> simply fetches the GUID of the volume of the handle, and constructs a valid Win32 path from that.</li>
<li><code>win32_path_namespace::any</code> means attempt <code>guid_volume</code> first, and if it fails (e.g. your file is on a network share) then it attempts <code>dos</code>. This semantic may change in the future, however any path emitted will always be a valid Win32 path. </li>
</ul>
<div class="fragment"><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;{ <span class="keywordflow">return</span> h._get_handle().current_path(); }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/llfio/v2.0/<a class="el" href="fs__handle_8hpp.html">fs_handle.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacellfio__v2__xxx.html">llfio_v2_xxx</a></li><li class="navelem"><a class="el" href="classllfio__v2__xxx_1_1fs__handle.html">fs_handle</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
